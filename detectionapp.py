# -*- coding: utf-8 -*-
"""detectionapp

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VKG3EHIgmXi-KKo3-Jy-IkCAHBi7g_Tq
"""

import torchvision
from torchvision import  transforms 
import torch
from torch import no_grad

import requests
import cv2
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

from contextlib import contextmanager
from io import StringIO
#from streamlit.report_thread import REPORT_CONTEXT_ATTR_NAME
from threading import current_thread
import streamlit as st
import sys
from time import sleep

from PIL import Image
import io
import numpy as np
from torch.utils.data import DataLoader

import os
from typing import Callable, List, NamedTuple, Tuple
import altair as alt

def get_predictions(pred,threshold=0.8,objects=None ):
  
    predicted_classes= [(COCO_INSTANCE_CATEGORY_NAMES[i],p,[(box[0], box[1]),(box[2], box[3])]) for i,p,box in zip(list(pred[0]['labels'].numpy()),pred[0]['scores'].detach().numpy(),list(pred[0]['boxes'].detach().numpy()))]
    predicted_classes=[  stuff  for stuff in predicted_classes  if stuff[1]>threshold ]
    
    if objects  and predicted_classes :
        predicted_classes=[ (name, p, box) for name, p, box in predicted_classes if name in  objects ]
    return predicted_classes

def draw_box(predicted_classes,image,rect_th= 10,text_size= 1,text_th=3):

     img=(np.clip(cv2.cvtColor(np.clip(image.numpy().transpose((1, 2, 0)),0,1), cv2.COLOR_RGB2BGR),0,1)*255).astype(np.uint8).copy()
     for predicted_class in predicted_classes:
   
        label=predicted_class[0]
        probability=predicted_class[1]
        box=predicted_class[2]
        bounding_box=pred[0]['boxes'][0].tolist()
        t,l,r,b=[round(x) for x in bounding_box]
        box[0]=(t,l)
        box[1]=(r,b)
   

        cv2.rectangle(img, box[0], box[1],(0, 255, 0), rect_th) # Draw Rectangle with the coordinates
        cv2.putText(img,label,box[0],  cv2.FONT_HERSHEY_SIMPLEX, text_size, (0,255,0),thickness=text_th) 
        cv2.putText(img,label+": "+str(round(probability,2)), box[0],  cv2.FONT_HERSHEY_SIMPLEX, text_size, (0,255,0),thickness=text_th)
     plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
     del(img)
     del(image)

def save_RAM(image_=False):
    global image, img, pred
    torch.cuda.empty_cache()
    del(img)
    del(pred)
    if image_:
        image.close()
        del(image)

model_ = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=True)
model_.eval()

for name, param in model_.named_parameters():
    param.requires_grad = False
print("done")

def model(x):
    with torch.no_grad():
        yhat = model_(x)
    return yhat

def prediction(image):
  transform = transforms.Compose([transforms.ToTensor()])
  img = transform(image)
  pred = model([img])

  pred_thresh=get_predictions(pred,threshold=0.50)
  draw_box(pred_thresh,img)
  del pred_thresh
  save_RAM(image_=True)

IMAGE_TYPES = ["png", "jpg"]
def set_environ():
    """Sets environment variables for logging etc."""
    os.environ["TF_CPP_MIN_LOG_LEVEL"] = "2"


def main():
    """Run this to run the application"""
    set_environ()

    st.title("object detection.")
    st.info(__doc__)
   # st.sidebar.subheader("detection")

    image = st.file_uploader("Upload a file for obect detection", IMAGE_TYPES)

    if image:
       st.image(image, use_column_width=True)
       image = Image.open(image)
      #progress_bar = st.empty()
       #progress = st.empty()
       half = 0.5
       image.resize( [int(half * s) for s in image.size] )
      
     

       st.subheader("detection")
       prediction(image)


main()